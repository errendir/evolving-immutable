import { Set, Map } from 'immutable'

import {
  memoizeForRecentArguments,
  semiPureFunction,
  unionMap, unionSet, flattenMap,
  zip, leftJoin, group, map, filter, toSet, toMap
} from './transformations'

describe('memoizeForRecentArguments', () => {
  it('produces a function that returns cached value if called with the arguments it has recently been called with', () => {
    // const decimalPart = (number) => Math.abs(number) - Math.floor(Math.abs(number))
    // const largeNumber = 1000000
    // const giveMeTheFirstPseudoRandomValue = (seed) => decimalPart(Math.sin(seed*largeNumber)*largeNumber)

    const objHash = memoizeForRecentArguments(Math.random, { historyLength: 20 })

    const obj1 = {}
    const obj2 = {}
    
    const hash1_1 = objHash(obj1)
    const hash2_1 = objHash(obj2)
    const hash1_2 = objHash(obj1)
    const hash2_2 = objHash(obj2)
    console.assert(hash1_1 === hash1_2)
    console.assert(hash2_1 === hash2_2)
  })
})

describe('filter', () => {
  it('produces a map with all the entries of the argument map for which the provided predicate function returns truthy', () => {
    const map = Map({ a: { value: 8 }, b: { value: 11 }, c: { value: 9 } })

    const lowerThan10 = filter(element => element.value < 10)

    const result = lowerThan10(map)
    console.assert(result.keySeq().toSet().equals(Set(["a", "c"])))
    console.assert(result.get("a") === map.get("a"))
    console.assert(result.get("c") === map.get("c"))
  })

  it('produced correct map when argument changes in discontinuous manner', () => {
    const map1 = Map({ a: { value: 8 }, b: { value: 11 }, c: { value: 9 }, d: { value: 3 } })
    const map2 = Map({ a: { value: 14 }, b: { value: 12 }, c: { value: 8 } })

    const lowerThan10 = filter(element => element.value < 10)

    lowerThan10(map1)
    const result = lowerThan10(map2)
    console.assert(result.keySeq().toSet().equals(Set(["c"])))
    console.assert(result.get("c") === map2.get("c"))
  })

  it('updates the result by removing any entry that predicate no longer accepts after argument change', () => {
    const map1 = Map({ a: { value: 8 }, b: { value: 11 }, c: { value: 9 } })
    const map2 = map1.set('a', { value: 12 })

    const lowerThan10 = filter(element => element.value < 10)

    lowerThan10(map1)
    const result = lowerThan10(map2)
    console.assert(result.keySeq().toSet().equals(Set(["c"])))
    console.assert(result.get("c") === map1.get("c"))
  })

  it('updates the result by adding any entry that predicate accepts after argument change', () => {
    const map1 = Map({ a: { value: 8 }, b: { value: 11 }, c: { value: 9 } })
    const map2 = map1.set('b', { value: 2 })

    const lowerThan10 = filter(element => element.value < 10)

    lowerThan10(map1)
    const result = lowerThan10(map2)
    console.assert(result.keySeq().toSet().equals(Set(["a", "b", "c"])))
    console.assert(result.get("a") === map2.get("a"))
    console.assert(result.get("b") === map2.get("b"))
    console.assert(result.get("c") === map2.get("c"))
  })
})

describe('zip', () => {
  it('produces a map with all the keys of both input maps', () => {
    const map1 = Map({ a: { a: 1 }, b: { a: 2 }, c: { c: 3 }})
    const map1_a = map1.remove('c')
    const map1_b = map1_a.set('f', { a: 124 })

    const map2 = Map({ c: { b: 1 }, d: { b: 2 }, e: { b: 3 }})

    const zipTwoObjects = zip((left, right) => ({...left, ...right}))

    const outputMap1 = zipTwoObjects(map1, map2)
    const outputMap2 = zipTwoObjects(map1_a, map2)
    const outputMap3 = zipTwoObjects(map1_b, map2)

    console.assert(outputMap1.keySeq().toSet().equals(Set(["a", "b", "c", "d", "e"])))
    console.assert(outputMap2.keySeq().toSet().equals(Set(["a", "b", "c", "d", "e"])))
    console.assert(outputMap3.keySeq().toSet().equals(Set(["a", "b", "c", "d", "e", "f"])))
  })

  it('produces a map with values generated by combining entries of the first argument with entries of the second argument by calling the provided attach function for each key', () => {
    const map1 = Map({ a: { a: 1 }, b: { a: 2 }, c: { c: 3 }})
    const map2 = Map({ a: { b: 1 }, b: { b: 2 } })

    const zipTwoObjects = zip((left, right) => ({ left, right }))

    const outputMap1 = zipTwoObjects(map1, map2)

    console.assert(outputMap1.get("a").left === map1.get("a"))
    console.assert(outputMap1.get("a").right === map2.get("a"))
    console.assert(outputMap1.get("b").left === map1.get("b"))
    console.assert(outputMap1.get("b").right === map2.get("b"))
    console.assert(outputMap1.get("c").left === map1.get("c"))
    console.assert(outputMap1.get("c").right === map2.get("c"))
  })

  it('does not remove entries from the resulting map as long as the key is present in at least one source maps', () => {
    const map1 = Map({ a: { a: 1 }, b: { a: 2 }, c: { c: 3 } })
    const map1_a = map1.remove('a')
    const map1_b = map1_a.remove('c')
    const map2 = Map({ a: { b: 1 }, b: { b: 2 }, c: { c: 3 } })
    const map2_a = map2.remove('b')

    const zipTwoObjects = zip((left, right) => ({ left, right }))

    const outputMap1 = zipTwoObjects(map1, map2)
    const outputMap2 = zipTwoObjects(map1_a, map2)
    const outputMap3 = zipTwoObjects(map1_b, map2)
    const outputMap4 = zipTwoObjects(map1_b, map2_a)

    console.assert(outputMap1.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap2.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap3.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap4.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
  })

  it('removed entries from the resulting map for keys no longer present in either source maps', () => {
    const map1 = Map({ a: { a: 1 }, b: { a: 2 }, c: { c: 3 } })
    const map1_a = map1.remove('a')
    const map1_b = map1_a.remove('c')
    const map2 = Map({ a: { b: 1 }, b: { b: 2 }, c: { c: 3 } })
    const map2_a = map2.remove('a')
    const map2_b = map2_a.remove('c')

    const zipTwoObjects = zip((left, right) => ({ left, right }))

    const outputMap1 = zipTwoObjects(map1, map2)
    const outputMap2 = zipTwoObjects(map1_a, map2)
    const outputMap3 = zipTwoObjects(map1_b, map2)
    const outputMap4 = zipTwoObjects(map1_b, map2_a)
    const outputMap5 = zipTwoObjects(map1_b, map2_b)

    console.assert(outputMap1.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap2.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap3.keySeq().toSet().equals(Set(['a', 'b', 'c'])))
    console.assert(outputMap4.keySeq().toSet().equals(Set(['b', 'c'])))
    console.assert(outputMap5.keySeq().toSet().equals(Set(['b'])))
  })
})

describe('group', () => {
  it('produces a map where keys are all the groups generated by the provided function', () => {
    const map = Map({ a: { v: 11 }, b: { v: 11 }, c: { v: 12 }})

    const groupByV = group(object => object.v)
    const groupedObjects = groupByV(map)

    console.assert(groupedObjects.keySeq().toSet().has(11))
    console.assert(groupedObjects.keySeq().toSet().has(12))
  })
  it('produces a map of maps of all elements belonging to a particual group', () => {
    const map = Map({ a: { v: 11 }, b: { v: 11 }, c: { v: 12 }})

    const groupByV = group(object => object.v)
    const groupedObjects = groupByV(map)

    console.assert(groupedObjects.get(11).has('a'))
    console.assert(groupedObjects.get(11).get('a') === map.get('a'))
    console.assert(groupedObjects.get(11).has('b'))
    console.assert(groupedObjects.get(11).get('b') === map.get('b'))
    console.assert(groupedObjects.get(12).has('c'))
    console.assert(groupedObjects.get(12).get('c') === map.get('c'))
  })
  it('correctly moves an element from one group to another when ran on a modified argument', () => {
    const map0 = Map({})
    const map1 = Map({ a: { v: 11 }, b: { v: 11 }, c: { v: 12 }})
    const map2 = map1.set('a', { v: 12 })

    const groupByV = group(object => object.v)
    groupByV(map0)
    groupByV(map1)
    const groupedObjects = groupByV(map2)

    console.assert(groupedObjects.get(11).has('b'))
    console.assert(groupedObjects.get(11).get('b') === map2.get('b'))
    console.assert(groupedObjects.get(12).has('a'))
    console.assert(groupedObjects.get(12).get('a') === map2.get('a'))
    console.assert(groupedObjects.get(12).has('c'))
    console.assert(groupedObjects.get(12).get('c') === map2.get('c'))
  })

  it('removes a group from the resulting map if no argument value remains in the group', () => {
    const map0 = Map({})
    const map1 = Map({ a: { v: 11 }, b: { v: 11 }, c: { v: 12 }})
    const map2 = map1.set('c', { v: 11 })

    const groupByV = group(object => object.v)
    groupByV(map0)
    groupByV(map1)
    const groupedObjects = groupByV(map2)

    console.log('groupedObjects', groupedObjects.toJS())
    console.assert(!groupedObjects.has(12))
  })
})

describe('leftJoin', () => {
  it('produces a map with each key of the first argument map', () => {
    const mapL = Map({ 'a': { otherEnd: 'a' }, 'b': { otherEnd: 'b' } })
    const mapR = Map({ 'a': {}, 'b': {}, 'c': {} })

    const leftJoinLR = leftJoin(
      (left) => Set([left.otherEnd]),
      (left, rights) => ({ left, right: rights.get(left.otherEnd) })
    )

    const mapLR = leftJoinLR(mapL, mapR)
    console.assert(mapLR.keySeq().toSet().equals(Set(['a', 'b'])))
  })

  it('uses the first provided function to find the values in the second argument map', () => {
    const l1 = { id: 1, uId: 1 }
    const l2 = { id: 2, uId: 2 }
    const l3 = { id: 3, uId: 3 }
    const mapL = Map([l1, l2, l3].map(l => ([l.id, l])))
    const u1 = { id: 1 }
    const u2 = { id: 2 }
    const u3 = { id: 3 }
    const mapU = Map([u1, u2, u3].map(u => ([u.id, u])))

    const getLU = leftJoin(
      l => Set([l.uId]),
      (l, us) => ({ l, u: us.get(l.uId) })
    )

    const lu = getLU(mapL, mapU)
    
    console.assert(lu.has(l1.id))
    console.assert(lu.get(l1.id).l === l1)
    console.assert(lu.get(l1.id).u === u1)
    console.assert(lu.has(l2.id))
    console.assert(lu.get(l2.id).l === l2)
    console.assert(lu.get(l2.id).u === u2)
    console.assert(lu.has(l3.id))
    console.assert(lu.get(l3.id).l === l3)
    console.assert(lu.get(l3.id).u === u3)
  })
})

describe('toSet', () => {
  it('produces a set of all the value of the provided map', () => {
    const o1 = {}
    const o2 = {}
    const map = Map({ a: o1, b: o1, c: o2 })
    const convertToSet = toSet()

    const set = convertToSet(map)
    console.assert(Set.isSet(set))
    console.assert(set.has(o1))
    console.assert(set.has(o2))
    console.assert(set.size === 2)
  })

  it('does not remove elements too eagerly when ran again on a map with removed keys', () => {
    const object1 = {}
    const object2 = {}
    const map1 = Map({
      "a": object1,
      "b": object1,
      "c": object1,
    })
    const map2 = map1.remove("a")
    const map3 = map2.set("b", object2)
    const convertToSet = toSet()
    
    console.assert(convertToSet(map1).has(object1))
    console.assert(convertToSet(map2).has(object1))
    console.assert(convertToSet(map3).has(object1))
  })
})

describe('toMap', () => {
  it('produces a map with entries generated from argument set values by attaching a key returned for each value by the attach function', () => {
    const o1 = { id: 1, val: 1}, o2 = { id: 2, val: 2}, o3 = { id: 3, val: 3}
    const set = Set([o1, o2, o3])

    const convertToMap = toMap(value => value.id)
    const result = convertToMap(set)

    console.assert(result.keySeq().toSet().equals(Set([1,2,3])))
    console.assert(result.get(1) === o1)
    console.assert(result.get(2) === o2)
    console.assert(result.get(3) === o3)
  })
})